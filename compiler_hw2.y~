/*	Definition section */

%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
extern int yylineno;
extern int yylex();

int Index = 0; 
char mID[20];
char mType[8];
int I_data;
float F_data;
char mString[87];

typedef struct symbol_table
{
        int Index;
        char mID[20];
        char mType[8];
        int I_data;
        float F_data;
        struct symbol_table *next;

}symbol_table;

/* Symbol table function - you can add new function if need. */
symbol_table *lookup_symbol(char const *);
void create_symbol();
void insert_symbol();
void dump_symbol();
void yyerror(char const *s) { fprintf(stderr, "%s\n", s); }

symbol_table *Table, *Head;

%}

/* Using union to define nonterminal and token type */
%union {
    int i_val;
    double f_val;
    char* string;
}

/* OTHERS PLEASE RETURN *YYTEXT */

/* Token without return NEED RETURN ! BUT NO TYPE*/
%token PRINT PRINTLN 
%token IF ELSE FOR
%token VAR NEWLINE
%token INT FLOAT VOID
%token INCREMENT DECREMENT

/* Token with return, which need to sepcify type */
%token <i_val> I_CONST 
%token <f_val> F_CONST 
%token <string> STRING
%token <string> ID

/* Nonterminal with return, which need to sepcify type */
%type <f_val> stat 
%type <i_val> CALC

/* Yacc will start at this nonterminal */
%start program

/* left */

%left '+' '-'
%left '*' '/'

/* Grammar section */
%%

program 
    : stat program 
    | 
;

stat
    : declaration
    | compound_stat
    | expression_stat
    | print_func
;

compound_stat :
;

print_func 
	: PRINT '(' I_STORE_ID ')' { printf("%s\n", mID); }
	| PRINTLN '(' I_STORE_ID ')' { printf("%s\n\n", mID); }
	| PRINT '(' I_STORE_STRING ')' { printf("%s\n", mString); }
	| PRINTLN '(' I_STORE_STRING ')' { printf("%s\n", mString); }
	| NEWLINE
;


declaration
    : VAR I_STORE_ID type '=' initializer { create_symbol(); }
    | VAR I_STORE_ID type { create_symbol(); }
    | NEWLINE
;

type
    : INT 	{ strcpy(mType, "int"); }
    | FLOAT 	{ strcpy(mType, "float32"); }
    | VOID 	{ strcpy(mType, "void"); }
;

I_STORE_ID
	: ID { strcpy(mID, $1); } 
;

I_STORE_STRING
	: STRING { strcpy(mString, $1); }
;

initializer 
	: ID
	| constant 
;

expression_stat 
	: IF_ELSE
	| FOR '{' expression_stat '}' 
	| CALC { printf("Ans = %d\n", $1);}
;

CALC 	: CALC '+' CALC { $$ = $1 + $3;}
	| CALC '-' CALC { $$ = $1 - $3;}
	| CALC '*' CALC { $$ = $1 * $3;}
	| CALC '/' CALC { $$ = $1 / $3;}
	| '(' CALC ')'	{ $$ = $2 ;}
	| ID 
	{ 
		if(!lookup_symbol($1))
		{ 
			printf("%s -->  Undeclared Varaible\n", $1); $$ = 1; 
		}
		else
		{
			$$ = lookup_symbol($1)->I_data;
		}	
	}
	| constant
	| NEWLINE
	| CALC INCREMENT { $$ = $$ + 1; }
	| CALC DECREMENT { $$ = $$ - 1; }
;

IF_ELSE : IF '{' expression_stat '}'
	| IF '{' expression_stat '}' ELSE '{' expression_stat '}'
;


constant
    : I_CONST { I_data = $1; }
    | F_CONST { F_data = $1; }
;

%%

/* C code section */
int main(int argc, char** argv)
{
    yylineno = 0;

    yyparse();

    return 0;
}

void create_symbol() 
{	
	if ( !Table )
	{
		fprintf(stdout, "Create symbol table\n");
		Table = malloc(sizeof(symbol_table));
		Head = Table;
	}

	insert_symbol();
}

void insert_symbol() 
{
	// set every variable
	Index ++;
	Table -> Index = Index;
	strcpy(Table -> mID, mID);
	strcpy(Table -> mType, mType);

	switch(mType[0])
	{
	case 'v' : break;
	case 'f' : Table -> F_data = F_data; break;
	case 'i' : Table -> I_data = I_data; break;
	default : puts("Non-type"); break;
	}

	printf("Insert symbol: %s\n", Table -> mID);

	Table -> next = malloc(sizeof(symbol_table));

	// Table point to next;
	Table = Table -> next;

	dump_symbol();
}

symbol_table *lookup_symbol(char const *Look_ID)
{
	if (!Head) return NULL;

	symbol_table *temp = Head;

	while(temp -> next != NULL)
	{
		if(strcmp(Look_ID, temp->mID) == 0)
		{
			return temp;
		}
		temp = temp -> next;
	}

	return NULL;
}

void dump_symbol()
{
	if ( !Head ) return;

        symbol_table *temp = Head;

        while(temp -> next != NULL)
        {
                fprintf(stdout, "Index : %d, ID : %s, Type : %s, Data : %d\n", temp->Index, temp->mID, temp->mType, temp->I_data);
		temp = temp -> next;
        }

}
